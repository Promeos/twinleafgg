// This file was auto-generated by the card stub generator.
// Card effects were implemented by an agent.
// If you have any questions or feedback, reach out to @C4 in the discord.

import { TrainerCard } from '../../game/store/card/trainer-card';
import { TrainerType } from '../../game/store/card/card-types';
import { StoreLike, State, StateUtils, GameMessage, ChooseCardsPrompt, Card, ConfirmPrompt } from '../../game';
import { Effect } from '../../game/store/effects/effect';
import { TrainerEffect } from '../../game/store/effects/play-card-effects';
import { PowerEffect } from '../../game/store/effects/game-effects';
import { Weezing } from './weezing';

export class JessieAndJames extends TrainerCard {
  public trainerType: TrainerType = TrainerType.SUPPORTER;
  public set: string = 'HIF';
  public setNumber: string = '58';
  public cardImage: string = 'assets/cardback.png';
  public name: string = 'Jessie & James';
  public fullName: string = 'Jessie & James HIF';
  public text: string = 'Each player discards 2 cards from their hand. Your opponent discards first. You may play only 1 Supporter card during your turn (before your attack).';

  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {
    // Ref: set-unbroken-bonds/honchkrow-gx.ts (Unfair-GX - opponent discard from hand)
    if (effect instanceof TrainerEffect && effect.trainerCard === this) {
      const generator = playCard(() => generator.next(), store, state, this, effect);
      return generator.next().value;
    }

    return state;
  }
}

function* playCard(next: Function, store: StoreLike, state: State,
  self: JessieAndJames, effect: TrainerEffect): IterableIterator<State> {
  const player = effect.player;
  const opponent = StateUtils.getOpponent(state, player);

  // Move to supporter zone, prevent default discard
  player.hand.moveCardTo(effect.trainerCard, player.supporter);
  effect.preventDefault = true;

  // Opponent discards first (up to 2 from their hand)
  if (opponent.hand.cards.length > 0) {
    const opponentMax = Math.min(2, opponent.hand.cards.length);
    yield store.prompt(state, new ChooseCardsPrompt(
      opponent,
      GameMessage.CHOOSE_CARD_TO_DISCARD,
      opponent.hand,
      {},
      { min: opponentMax, max: opponentMax, allowCancel: false }
    ), (selected: Card[] | null) => {
      const cards = selected || [];
      opponent.hand.moveCardsTo(cards, opponent.discard);
      next();
    });
  }

  // Player discards 2 cards
  let playerDiscarded: Card[] = [];
  const playerCardsInHand = player.hand.cards.length;
  if (playerCardsInHand > 0) {
    const playerMax = Math.min(2, playerCardsInHand);
    yield store.prompt(state, new ChooseCardsPrompt(
      player,
      GameMessage.CHOOSE_CARD_TO_DISCARD,
      player.hand,
      {},
      { min: playerMax, max: playerMax, allowCancel: false }
    ), (selected: Card[] | null) => {
      playerDiscarded = selected || [];
      player.hand.moveCardsTo(playerDiscarded, player.discard);
      next();
    });
  }

  // Check for Weezing's "Surrender Now" ability in player's discarded cards
  // Ref: Weezing HIF (Surrender Now) - triggers when discarded by Jessie & James
  const weezingCards = playerDiscarded.filter(c => c instanceof Weezing);
  for (const weezingCard of weezingCards) {
    const weezing = weezingCard as Weezing;
    // Check if ability is blocked
    try {
      const powerEffect = new PowerEffect(player, weezing.powers[0], weezing);
      store.reduceEffect(state, powerEffect);
    } catch {
      continue;
    }

    if (opponent.hand.cards.length > 0) {
      let useAbility = false;
      yield store.prompt(state, new ConfirmPrompt(
        player.id,
        GameMessage.WANT_TO_USE_ABILITY,
      ), result => {
        useAbility = result;
        next();
      });

      if (useAbility) {
        const discardCount = Math.min(1, opponent.hand.cards.length);
        yield store.prompt(state, new ChooseCardsPrompt(
          player,
          GameMessage.CHOOSE_CARD_TO_DISCARD,
          opponent.hand,
          {},
          { min: discardCount, max: discardCount, allowCancel: false }
        ), (selected: Card[] | null) => {
          const cards = selected || [];
          opponent.hand.moveCardsTo(cards, opponent.discard);
          next();
        });
      }
    }
  }

  // Clean up supporter
  player.supporter.moveCardTo(effect.trainerCard, player.discard);

  return state;
}
