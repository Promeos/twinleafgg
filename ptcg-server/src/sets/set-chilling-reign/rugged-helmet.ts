// This file was auto-generated by the card stub generator.
// Card effects were implemented by an agent.
// If you have any questions or feedback, reach out to @C4 in the discord.

import { TrainerCard } from '../../game/store/card/trainer-card';
import { TrainerType, SuperType } from '../../game/store/card/card-types';
import { StoreLike, State, ChooseCardsPrompt, GameMessage, GamePhase } from '../../game';
import { Effect } from '../../game/store/effects/effect';
import { AfterDamageEffect } from '../../game/store/effects/attack-effects';
import { StateUtils } from '../../game/store/state-utils';
import { ToolEffect } from '../../game/store/effects/play-card-effects';
import { MOVE_CARDS } from '../../game/store/prefabs/prefabs';

export class RuggedHelmet extends TrainerCard {
  public trainerType: TrainerType = TrainerType.TOOL;
  public regulationMark: string = 'E';
  public set: string = 'CRE';
  public setNumber: string = '152';
  public cardImage: string = 'assets/cardback.png';
  public name: string = 'Rugged Helmet';
  public fullName: string = 'Rugged Helmet CRE';
  public text: string = 'Attach a Pokémon Tool to 1 of your Pokémon that doesn\'t already have a Pokémon Tool attached. If the Pokémon this card is attached to is in the Active Spot and is damaged by an attack from your opponent\'s Pokémon (even if it is Knocked Out), put an Energy attached to the Attacking Pokémon into your opponent\'s hand. You may play any number of Item cards during your turn.';

  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {
    // Ref: set-scarlet-and-violet/rocky-helmet.ts (AfterDamageEffect tool pattern),
    //      set-plasma-freeze/rock-guard.ts (tool attached to target + attacker retaliation)
    if (effect instanceof AfterDamageEffect && effect.target.tools.includes(this)) {
      const player = effect.player;
      const targetPlayer = StateUtils.findOwner(state, effect.target);

      if (effect.damage <= 0 || player === targetPlayer || targetPlayer.active !== effect.target) {
        return state;
      }

      // Try to reduce ToolEffect to check if something is blocking the tool
      try {
        const stub = new ToolEffect(effect.player, this);
        store.reduceEffect(state, stub);
      } catch {
        return state;
      }

      if (state.phase === GamePhase.ATTACK) {
        // Get energy attached to the attacking Pokemon
        const attackerEnergyCards = effect.source.cards.filter(c => c.superType === SuperType.ENERGY);

        if (attackerEnergyCards.length === 0) { return state; }

        // If only one energy, take it automatically; otherwise let target player choose
        if (attackerEnergyCards.length === 1) {
          MOVE_CARDS(store, state, effect.source, targetPlayer.hand, { cards: [attackerEnergyCards[0]], sourceCard: this });
        } else {
          return store.prompt(state, new ChooseCardsPrompt(
            targetPlayer,
            GameMessage.MOVE_ENERGY_CARDS,
            effect.source,
            { superType: SuperType.ENERGY },
            { min: 1, max: 1, allowCancel: false }
          ), selected => {
            if (selected && selected.length > 0) {
              MOVE_CARDS(store, state, effect.source, targetPlayer.hand, { cards: selected, sourceCard: this });
            }
          });
        }
      }
    }

    return state;
  }
}
